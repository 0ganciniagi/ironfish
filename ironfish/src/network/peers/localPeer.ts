/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
import { Identity, PrivateIdentity, privateIdentityToIdentity } from '../identity'
import { Identify, InternalMessageType } from '../messages'
import { IsomorphicWebRtc, IsomorphicWebSocketConstructor } from '../types'
import { parseVersion, renderVersion, Version } from '../version'
import { boxMessage, unboxMessage } from './encryption'

/**
 * Wraps configuration needed for establishing connections with other peers
 * and maintains references to all known peers.
 */
export class LocalPeer {
  // our keypair for encrypting messages
  private readonly privateIdentity: PrivateIdentity
  // the identity we expose to other peers
  readonly publicIdentity: Identity
  // the version of the local client
  readonly version: Version
  // constructor for either a Node WebSocket or a browser WebSocket
  readonly webSocket: IsomorphicWebSocketConstructor
  // optional object containing a Node implementation of WebRTC
  readonly webRtc: IsomorphicWebRtc
  // optional port the local peer is listening on
  port: number | null
  // optional a human readable name for the node
  name: string | null
  // is the node a worker node that should not be advertised
  isWorker = false
  // should we broadcast worker nodes anyway?
  broadcastWorkers = true
  // simulated latency in MS that gets added to connection.send
  simulateLatency = 0

  constructor(
    identity: PrivateIdentity,
    version: string,
    webSocket: IsomorphicWebSocketConstructor,
    webRtc?: IsomorphicWebRtc,
  ) {
    this.privateIdentity = identity
    this.publicIdentity = privateIdentityToIdentity(identity)
    this.version = parseVersion(version)

    if (
      this.version.product === null ||
      this.version.agent === null ||
      this.version.version === null
    ) {
      throw new Error(`Invalid local version ${version} -- example formatting: "sdk/1/cli"`)
    }

    this.webSocket = webSocket
    this.webRtc = webRtc
    this.port = null
    this.name = null
    this.isWorker = false
  }

  /**
   * Construct an Identify message with our identity and version.
   */
  getIdentifyMessage(): Identify {
    return {
      type: InternalMessageType.identity,
      payload: {
        identity: this.publicIdentity,
        isWorker: this.isWorker || undefined,
        version: renderVersion(this.version),
        name: this.name || undefined,
        port: this.port,
      },
    }
  }

  /**
   * Encrypt a string for recipient with the stored private identity.
   * @param plainTextMessage The string to encrypt.
   * @param recipient The public key of the recipient of the message.
   */
  boxMessage(
    plainTextMessage: string,
    recipient: Identity,
  ): { nonce: string; boxedMessage: string } {
    return boxMessage(plainTextMessage, this.privateIdentity, recipient)
  }

  /**
   * Decrypt a message using a nonce from a sender.
   * @param boxedMessage An encrypted message string.
   * @param nonce A nonce, generated by boxMessage.
   * @param sender The public key of the message sender.
   */
  unboxMessage(boxedMessage: string, nonce: string, sender: Identity): string | null {
    return unboxMessage(boxedMessage, nonce, sender, this.privateIdentity)
  }
}
